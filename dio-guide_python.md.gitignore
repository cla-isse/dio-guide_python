# ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)
Ol√°, pessoa bonita! Tudo bem com voc√™? 

Este √© um resumo constru√≠do com base no curso "Introdu√ß√£o √† Ci√™ncia de Dados e Python", na plataforma [DIO](https://web.dio.me/home).

Mentor: [@guicarvalho](https://github.com/guicarvalho)

## Sum√°rio

[1. Ambiente de desenvolvimeto e Primeiros Passos com Python](#1-ambiente-de-desenvolvimeto-e-primeiros-passos-com-python)
* [1.1 Introdu√ß√£o ao Python](#11-introdu√ß√£o-ao-python)
* [1.2 Configuara√ß√£o do Ambiente de Desenvolvimento](#12-configura√ß√£o-do-ambiente-de-desenvolvimento)
* [1.3 Primeiro Programa](#13-primeiro-programa)

[2. Conhecendo a Linguagem de Programa√ß√£o Python](#2-conhecendo-a-linguagem-de-programa√ß√£o-python)
* [2.1 Tipos de Dados](#21-tipos-de-dados)
* [2.2 Modo Interativo](#22-modo-interativo)
* [2.3 Vari√°veis e Constantes](#23-vari√°veis-e-constantes)
* [2.4 Convers√£o de Tipos](#24-convers√£o-de-tipos)
* [2.5 Fun√ß√µes de Entrada e Sa√≠da](#25-fun√ß√µes-de-entrada-e-sa√≠da)

[3. Tipos de Operadores](#3-tipos-de-operadores)
* [3.1 Operadores Aritm√©ticos](#31-operadores-aritm√©ticos)
* [3.2 Operadores de Compara√ß√£o](#32-operadores-de-compara√ß√£o)
* [3.3 Operadores de Atribui√ß√£o](#33-operadores-de-atribui√ß√£o)
* [3.4 Operadores L√≥gicos](#34-operadores-l√≥gicos)
* [3.5 Operadores de Identidade](#35-operadores-de-identidade)
* [3.6 Operadores de Associa√ß√£o](#36-operadores-de-associa√ß√£o)

[4. Estruturas Condicionais e de Repeti√ß√£o](#4-estruturas-condicionais-e-de-repeti√ß√£o)
* [4.1 Indenta√ß√£o e Blocos](#41-indenta√ß√£o-e-blocos)
* [4.2 Estruturas Condicionais](#42-estruturas-condicionais)
* [4.3 Estruturas de Repeti√ß√£o](#43-estruturas-de-repeti√ß√£o)

[5. Strings](#5-manipulando-strings)
* [5.1 Conhecendo M√©todos √öteis da Classe String](#51-conhecendo-m√©todos-√∫teis-da-classe-string)
* [5.2 Interpola√ß√£o de Vari√°veis](#52-interpola√ß√£o-de-vari√°veis)
* [5.3 Fatiamento de String](#53-fatiamento-de-strings)
* [5.4 String de m√∫ltiplas linhas](#54-string-de-m√∫ltiplas-linhas)

[6. Listas e Tuplas](#6-listas)
* [6.1 Cria√ß√£o de Listas e Acesso aos Dados](#61-cria√ß√£o-e-acesso-aos-dados)
* [6.2 M√©todos da Classe list](#62-m√©todos-da-classe-list)

[7. Conjuntos](#7-conjuntos)
* [7.1 Cria√ß√£o de Conjuntos e Acesso aos Dados](#71-cria√ß√£o-e-acesso-aos-dados)
* [7.2 M√©todos da Classe set](#72-m√©todos-da-classe-set)

[8. Dicion√°rios](#8-dicion√°rios)
* [8.1 Cria√ß√£o de Dicion√°rios e Acesso aos Dados](#81-cria√ß√£o-de-dicion√°rios-e-acesso-aos-dados)
* [8.2 M√©todos da Classe dict](#82-m√©todos-da-classe-dict)

[9. Fun√ß√µes](#9-fun√ß√µes)

---
## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 1. Ambiente de desenvolvimeto e Primeiros Passos com Python

#### 1.1 Introdu√ß√£o ao Python

Python foi Criado, em 1989, por Guido Van Rossum. A ideia original era dar continuidade a linguagem ABC. Logo, foi muito influenciado pela linguagem ABC, pensada para iniciantes.

* Linguagem f√°cil e intuitiva;
* C√≥digo aberto;
* C√≥digo t√£o intelig√≠vel quanto o ingl√™s (s√≠ntaxe bonita);
* Adequada para tarefas di√°rias e produtiva.

```mermaid
  flowchart TD;
      A[1991]-- Lan√ßada a primeira vers√£o p√∫blica do Python, 0.9.0 -->B[1994]
      B-- Lan√ßada a vers√£o 1.0 -->C[1995]
      C-- Lan√ßada a vers√£o 1.2. <br> Guido e a equipe principal de desenvolvedroes Python <br> mudam-se para BeOpen. Nasce BeOpen Python Labs -->D[2000]
      D-- Nasce a segunda vers√£o do Python. -->E[2001]
      E-- Python Software Foundation -PSF- √© fundada -->F[2008]
      F-- Lan√ßada a ves√£o 3.0 do Python. <br> N√£o √© retrocompat√≠vel. -->G[...]
```
Atualmente o estamos na vers√£o 3.10.2 do Python.

##### Onde utilizar o Python?

√â um linguagem vers√°til. 
* Tipagem din√¢mica e forte;
* Multiplataforma e multiparadigma;
* Comunidade grande e ativa;
* Curva de aprendizado baixa.

S√≥ n√£o √© uma boa para apps mobile.

#### 1.2 Configura√ß√£o do ambiente de desenvolvimento

Nos sistemas operacionais Linux e MacOS, √© prov√°vel que o Python j√° esteja instalado.

> Para verificar a vers√£o instalada do Python, basta abrir o cmd e inserir o comando:

```cmd
python -V
```

No Windows, o Python pode ser baixado por este link: http://www.python.org

Para a instala√ß√£o, √© s√≥ seguir os passos neste [tutorial](https://python.org.br/instalacao-windows/.).

#### 1.3 Primeiro Programa

Exibe, na tela, uma mensagem de boas-vindas.

```python
print("Ol√° Mundo!")
```
---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 2. Conhecendo a Linguagem de Programa√ß√£o Python

#### 2.1 Tipos de Dados

Tipos servem para denifir as caracer√≠sticas e comportamentos de um objeto para o interpretador.

Os tipos built-in mais comuns s√£o:

|Tipo|Classe|
|---|---|
|Texto|str|
|Num√©rico|int, float, complex|
|Sequ√™ncia|list, tuple, range|
|Mapa|dict|
|Cole√ß√£o|set, frozenset|
|Booleano|bool|
|Bin√°rio|bytes, bytearray, memoryview|

> Mapa = chave:valor ->  nome:guilherme

#### Tipos Num√©ricos

##### N√∫meros Inteiros

S√£o representados pela classe **int** e possuem precis√£o ilimitada.
>Ex. 1, 10, 100

##### N√∫meros de ponto flutuante

S√£o usados para representar os n√∫meros racionais e sua implementa√ß√£o √© feita pela classe **float**.
> Ex. 1.5, -10.435, 0.75

#### Tipo Booleano

√â usado para representar valores de verdadeiro ou falso, e √© impementado pela classe **bool**. 
* Em Python, √© uma subclasse de **int**, uma vez que qualquer n√∫mero diferente de 0 representa **verdadeiro** e 0 representa **falso**.

> Ex. True e False

#### Tipo Texto

Strings, ou cadeia de caracteres, s√£o usadas para representar valores alfanum√©ricos. Em Python, s√£o definidas pela classe **str**.

> Ex. "Python", 'Python', """Python""", 'p'

#### 2.2 Modo Interativo

No VSCode Studio, √© poss√≠vel ativar o modo interativo do interpretador Python no terminal.

Basta escrever:
```python
python
```

ou executando o script com a flag -i:
```python
python -i nome-do-arquivo.py
```
Para sair do modo interatitvo:
```python
exit()
```

Dessa forma, √© poss√≠vel executar comandos (como opera√µes num√©ricas, por exemplo) sem a necessidade de escrever e executar um script.

##### dir()

A fun√ß√£o **dir**, sem argumentos, retorna a lista de nomes no escopo local atual. Com um argumento, retorna uma lista de atributos v√°lido para o objeto.

```python
dir()
```

##### help()

A fun√ß√£o **help** invoca o sistema de ajuda integrado. √â poss√≠vel fazer buscas em modo interativo ou informar por par√¢metro qual o nome do m√≥dulo, fun√ß√£o, classe, m√©todo ou vari√°vel.

```python
help()
```
#### 2.3 Vari√°veis e Constantes

##### Vari√°veis

**Var√°veis** s√£o valores (objetos) que podem sofrer varia√ß√µes ao longo da execu√ß√£o de um programa.

N√£o √© preciso declarar o tipo de dados da vari√°vel, o Python reconhece automaticamente.

Dessa forma, n√£o√© poss√≠vel declarar uma vari√°vel sem um valor atribu√≠do.

* Para alterar o valor de uma vari√°vel, basta fazer a tribui√ß√£o de um novo valor.

```python
name = 'Gui'
age = 23
# ou name, age = ('Gui', 23)

print(f'Meu nome √© {name} e eu tenho {age} anos de idade.')
>>> Meu nome √© Gui e eu tenho 23 anos de idade
```

##### Constantes

**Constantes** s√£o valores (objetos) que **N√ÉO** podem sofrer varia√ß√µes ao longo da execu√ß√£o de um programa. O valor √© imut√°vel.

Contudo, n√£o existe uma palavra reservada, em Python, para informar ao interpretador que o valor √© constante.

Em Python, usamos a **conven√ß√£o** que diz ao **programador** que determinado valor √© uma constante. Para fazer isso, o valor deve ser declarado com todas as letras ma√≠usculas.

```python
ABS_PATH = '/home/gui/Documents/python_course/'

STATES = [
  'SP',
  'RJ',
  'MG',
]

AMOUNT = 30.2
```

##### Boas Pr√°ticas

* O padr√£o de nomes deve ser **snake_case**;
* Nomes devem ser intuitivos e sugestivos;
* Nome de constantes todo em ma√≠usculo.

#### 2.4 Convers√£o de Tipos

Pode ser necess√°rio converter o tipo de uma vari√°vel para que seja manipulada de forma diferente. 

>Ex. Uma vari√°vel string que armazena um n√∫mero que passar√° por alguma opera√ß√£o matem√°tica.

##### int para float
```python
preco = 10
print(preco)
>>> 10

preco = float(preco)
print(preco)
>>> 10.0

# Para voltar de float para int:
preco = int(preco)
print(preco)
>>> 10
```

##### num√©rico para string
```python
preco = 10.50
idade = 23

print(str(preco))
>>> 10.5

# ou

texto = f"idade {idade} preco {preco}"
print(texto)
>>> idade 28 preco 10.5
```

##### string para num√©rico

```python
preco = "10.50"
idade = "28"

print(float(preco))
>>> 10.50

print(int(idade))
>>> 28
```
#### 2.5 Fun√ß√µes de entrada e sa√≠da

input -> output

##### Fun√ß√£o input()

A fun√ß√£o built-in **input()** √© utilizada quando queremos ler dados de entrada padr√£o (teclado). Ela recebe um argumento do tipo string, que √© exibido para o usu√°rio na sa√≠da padr√£o (tela). 

A fun√ß√£o l√™ a entrada, converte para string e retorna o valor.

```python
nome = input("Informe seu nome: ")
>>> Informe o seu nome: |
```

##### Fun√ß√£o print()

A fun√ß√£o built-in **print()** √© utilizada quando queremos exibir dados na sa√≠da padr√£o (tela). 

Ela recebe um argumento onrigat√≥rio, do tipo varargs de objetos e 4 argumentos opcionais (sep, end, file e flush). 

Todos os objetos s√£o convertidos para string, separados por *sep* e terminados por *end*. A string final √© exibida para o usu√°rio.

```python
nome = "Janaina"
sobrenome = "Souza"

print(nome, sobrenome)
>>> Jananina Souza

pritn(nome, sobrenome, sep="-" end="...\n")
>>> Janaina-Souza...
```
---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 3. Tipos de Operadores

#### 3.1 Operadores aritm√©ticos

Os operadores aritm√©ticos executam opera√ß√µes matem√°ticas.

|Opera√ß√£o|Operador|
|---|---|
|Soma|+|
|Subtra√ß√£o|-|
|Multiplica√ß√£o|*|
|Divis√£o Real|/|
|Divis√£o Inteira|//|
|M√≥dulo|%|
|Exponencia√ß√£o|**|


> A **divis√£o inteira** n√£o retorna a parte decimal da divis√£o.
> 
> O **m√≥dulo** retorna apenas o resto da divis√£o.

##### Preced√™ncia dos operadores

A execu√ß√£o das opera√ß√µes matem√°icas segue a seguinte ordem:

```mermaid
flowchart LR;
      A[par√™ntesis]-->B[expoente]-->C[multiplica√ß√£o e divis√£o <br> da esquerda para a direita]-->D[soma e subtra√ß√£o <br> da esquerda para a direita]
```

#### 3.2 Operadores de Compara√ß√£o

Os operadores de compara√ß√£o servem para comparar dois valores.

|Opera√ß√£o|Operador|
|---|---|
|Igual|==|
|Diferente|!=|
|Maior|>|
|Maior ou Igual|>=|
|Menor|<|
|Menor ou Igual|<=|

> OBS: O operador **=** j√° est√° reservado para atribui√ß√£o, por isso a compara√ß√£o "igual" √© feita com **==**.

#### 3.3 Operadores de Atribui√ß√£o

Os operadores de atribui√ß√£o servem para definir o valor inicial ou sobrescrever o valor de uma vari√°vel.

##### Atribui√ß√£o simples

```python
saldo = 500
print(saldo)
>>> 500
```
##### Atribui√ß√£o com adi√ß√£o ou subtra√ß√£o

```python
saldo = 500
saldo +=200
print(saldo)
>>> 700
```

##### Atribui√ß√£o com multiplica√ß√£o

```python
saldo = 500
saldo *= 2
print(saldo)
>>> 1000
```

##### Atribui√ß√£o com divis√£o

```python
saldo = 500
saldo /= 5
print(saldo)
>>> 100.0

saldo = 500
saldo //= 5
>>> 100
```

##### Atribui√ß√£o com mu√≥dulo

```python
saldo = 500
saldo %= 4
print(saldo)
>>> 20
```

##### Atribui√ß√£o com exponencia√ß√£o

```python
saldo = 8
saldo **= 2
print(saldo)
>>> 64
```

#### 3.4 Operadores L√≥gicos

Operadores l√≥gicos s√£o utilizados em conjunto com os operadores de compara√ß√£o, para montar uma express√£o l√≥gica. 

Quando um operador de compara√ß√£o √© utilizado, o resultado retornado √© um booleano, dessa forma podemos combinar operadores de compara√ß√£o com os operadores l√≥gicos.

```python
saldo = 1000
saque = 200
limite = 100

saldo >= saque
>>> True

saque <= limite
>>> False
```

##### Operador E

```python
saldo >= saque and saque <=limite
>>> False
```

A express√£o √© verdadeira apenas se todas as afirma√ß√µes forem verdadeiras.

##### Operador OR

```python
saldo >= saque or saque <=limite
>>> False
```
A express√£o √© verdadeira apenas se pelo menos uma afirma√ß√£o for verdadeiras.

##### Operador NOT

```python
contatos_emergencia = []

not 1000 > 1500
>>> True
# 1000 n√£o √© maior que 1500?

not contatos_emergencia
>>> True
# O valor booleano de uma lista vazia √© falso. 
# not false = True

not ""
>>> True
# O valor booleano de uma string vazia √© falso.
# not false = True

not "saque 1500;"
>>> False
# O valor booleano de uma string √© verdadeiro.
# not verdadeiro = False
```

> Sequ√™ncias vazias, em Python, tem o valor booleano **False**.

##### Par√™nteses

Por conven√ß√£o, assim como nas opera√ß√µes matem√°ticas, nas opera√ß√µes l√≥gicas os par√™ntes servem para determinar a preced√™ncia, ou seja, a sequ√™ncia em que a express√£o √© analisada no c√≥digo.

O exemplo abaixo representa um sistema banc√°rio de saque que segue as regras: 
* N√£o se pode sacar um valor maior que o dispon√≠vel na conta.
* N√£o se pode sacar um valor maior que o limite di√°rio de saque.
* Se a conta for especial, n√£o h√° limite di√°rio de saque.

```python
saldo = 1000
saque = 250
limite = 200
conta_especial = True

print((saldo >= saque and saque <= limite) or (conta_especial and saldo >= saque))
>>> True

# ou

saque_conta_normal = saldo >= saque and saque <= limite
saque_conta_especial = conta_especial and saldo >= saque

print(saque_conta_normal or saque_conta_especial)
```

#### 3.5 Operadores de Identidade

Operadores de identidade √£o utilizados para comparar se os dois objetos testados ocupam a mesma posi√ß√£o na mem√≥ria.

```python
curso = "Curso de Python"
nome_curso = curso
saldo, limite = 200, 200

curso is nome_curso
>>> True

curso is not nome_curso
>>> False

saldo is limite
>>> True
```

#### 3.6 Operadores de Associa√ß√£o

Operadores de associa√ß√£o utilizados para verificar se um objeto est√° presente em uma sequ√™ncia.

> S√£o case sensitive.


```python
curso = "Curso de Python"
frutas = ["laranja","uva","lim√£o"]
saques = [1500,100]

"Python" in curso
>>> True

"ma√ß√£" not in frutas
>>> True

200 in saques
>>> False
```
---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 4. Estruturas Condicionais e de Repeti√ß√£o

#### 4.1 Indenta√ß√£o e Blocos

Indentar c√≥digo √© uma forma de manter o c√≥digo fonte mais leg√≠vel e manuten√≠vel. Mas em Python ela exerce um segundo papel, atrav√©s da indenta√ß√£o o interpretador consegue determinar onde um bloco de comando inicia e onde ele termina.

As linguagens de programa√ß√£o costumam utilizar caracteres ou palavras reservadas para terminar o in√≠cio e fim do bloco. Em Java e C por exemplo, utilizamos chaves:

```java
void sacar(double valor) { // in√≠cio do bloco do m√©todo
  if(this.saldo >= valor) { // in√≠cio do bloco do if
    this.saldo -= valor;
  } // fim do bloco do if
} // fim do bloco do m√©todo
```

Por√©m, o c√≥digo ainda funciona sem indenta√ß√£o:

```java
void sacar(double valor) {
if(this.saldo >= valor) {
this.saldo -= valor;
}
}
```

O mesmo n√£o acontece em Python.

```python
def sacar(self, valor:float) -> Nome # In√≠cio do bloco do m√©todo
    if self.saldo >= valor # in√≠cio do bloco if
        self.saldo -= valor
    # fim do bloco if
# fim do bloco do m√©todo
```

#### 4.2 Estruturas Condicionais

Uma estrutura condicional permite o desvio de fluxo de controle, quando determinadas express√µes l√≥gicas s√£o atendidas.

##### If

Para criar uma estrutura condicional simples, composta por um √∫nico desvio, podemos utilizar a palavra reservada **if**. 

O comando ir√° testar a express√£o l√≥gica, e em caso de retorno verdadeiro as a√ß√µes presentes no bloco de c√≥digo do if ser√£o executadas.

```python
saldo = 2000.0
saque = float(input(f"Voc√™ possui um saldo de R${saldo}. Informe o valor do saque: "))

if saldo >= saque:
  print("Saque Realizado!")

if saldo < saque:
  print("Saldo Insuficiente!")
```

##### If/Else

Para criar uma estrutura condicional com dois desvios, podemos utilizar as palavras reservadas **if** e **else**. 

Se a express√£o l√≥gica testada no if for verdadeira, ent√£o o bloco de c√≥digo do if ser√° executado. Caso contr√°rio, o bloco de c√≥digo do else ser√° executado.

```python
saldo = 2000.0
saque = float(input(f"Voc√™ possui um saldo de R${saldo}. Informe o valor do saque: "))

if saldo >= saque:
  print("Saque Realizado!")
else:
  print("Saldo Insuficiente!")
```

##### If/Elif/Else

Em alguns cen√°rios queremos mais de dois desvios, para isso podemos utilizar a palavra reservada **elif**. 

O elif √© composto por uma nova express√£o l√≥gica, que ser√° testada e caso retorne verdadeiro o bloco de c√≥digo do elif ser√° executado. 

* N√£o existe um n√∫mero m√°ximo de elifs que podemos utilizar, por√©m evite criar grandes estruturas condicionais, pois elas **aumentam a complexidade do c√≥digo**.

```python
opcao = int(input("Informe uma op√ß√£o: [1] Sacar \n [2] Extrato"))

if opcao == 1:
  valor = float(input("Informe o valor do saque: "))
  print(f"Voc√™ sacou R${valor}")

elif opcao == 2:
  print("Exibindo o Extrato")

else:
  exit("Op√ß√£o Inv√°lida")
```

##### If aninhado

Podemos criar estruturas condicionais aninhadas, para isso basta adicionar estruturas if/elif/else dentro do bloco de c√≥digo de estruturas if/elif/else.

```python
if conta_normal:
  if saque <= saldo:
    print("Saque realizado com sucesso!")
    elif saque >= (saldo + cheque_especial):
      print("Saque realizado com uso do cheque especial")
elif conta_univers√≠t√°ria:
  if saque <= saldo:
    print("Saque realizado com sucesso!")
  else:
    print("Saldo insuficiente")
```

##### If tern√°rio

O if tern√°rio permite escrever uma condi√ß√£o em uma √∫nica linha. Ele √© composto por tr√™s partes:
1. O retorno caso a express√£o retorne verdadeiro.
2. A express√£o l√≥gica. 
3. retorno caso a express√£o n√£o seja atendida.

```python
status = "Sucesso" if saldo >= saque else "Falha"

print(f"{status} ao realizar o saque!")
```

#### 4.3 Estruturas de Repeti√ß√£o

Estruturas de repeti√ß√£o s√£o utilizadas para repetir um trecho de c√≥digo um determinado n√∫mero de vezes. 
* Esse n√∫mero pode ser conhecido previamente ou determinado atrav√©s de uma express√£o l√≥gica.

Receba um n√∫mero do teclado e exiba os 2 n√∫meros seguintes:

```python
# Sem repeti√ß√£o 

a = int(input("Informe um n√∫mero inteiro: "))
print(a)

a += 1
print(a)

a += 1
print(a)
```

```python
# Com repeti√ß√£o 

a = int(input("Informe um n√∫mero inteiro: "))
print(a)

"repita 2 vezes":
  a += 1
  print(a)
```

##### For

O comando for √© usado para percorrer um objeto iter√°vel. Faz sentido usar for quando sabemos o n√∫mero exato de vezes que nosso bloco de c√≥digo deve ser executado, ou quando queremos percorrer um objeto iter√°vel.

```python
texto = input("Informe um texto: ")
VOGAIS = "AEIOU"

for letra in texto:
  if letra.upper() in VOGAIS
    print(letra, end="")

else:
  print() #adiciona um quebra de linha
```

##### Range

Range √© uma fun√ß√£o built-in do Python usada para produzir uma sequ√™ncia de n√∫meros inteiros a partir de um √≠nicio (inclusivo) para um fim (exclusivo). 

Se usarmos range(i, j) ser√° produzido: 

> i, i+1, i+2, i+3, ..., j-1.

Ela recebe 3 argumentos:
* stop (obrigat√≥rio);
* start (opcional);
* step (opcional).

```python
range(start, stop, step) -> range object
```

```python
list(range(4))
>>> [0, 1, 2, 3]
```

##### Range + For

```python
for numero in range(0, 11):
  print(numero, end=" ")
>>> 0 1 2 3 4 5 6 7 8 9 10

# Exibindo a tabuada do 5
for numero in range(0, 51, 5):
  print(numero, end=" ")
> 0 5 10 15 20 25 30 35 40 45 50
```

##### While

O comando while √© usado para repetir um bloco de c√≥digo v√°rias vezes. Faz sentido usar while quando n√£o sabemos o n√∫mero exato de vezes que nosso bloco de c√≥digo deve ser executado.

```python
opcao = 3

while opcao != 0:
  opcao = int(input("[1] Sacar \n [2] Extrato \n [0] Sair \n"))
  if opcao == 1:
    print("Sacando")
    break # interrompe o looping
  elif opcao == 2:
    print("Exibindo o Extrato")
    break # interrompe o looping
  elif opcao == 0:
    print("Agradecemos por escolher nossos servi√ßos!")
  else: 
    print("Escolha uma op√ß√£o v√°lida.")
```

> O comando **break** interrompe a execu√ß√£o do c√≥digo. O comando **continue** ignora o trecho do c√≥digo ao qual se refere.

---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 5. Strings

#### 5.1 Conhecendo M√©todos √öteis da Classe String

A classe String do Python √© famosa por ser rica em m√©todos e possuir uma interface muito f√°cil de trabalhar.

Em algumas linguagens manipular sequ√™ncias de caracteres n√£o √© um trabalho trivial, por√©m, em Python esse trabalho √© muito simples.

##### Ma√≠uscula, min√∫scula e t√≠tulo

```python
curso = "pYThOn"

print(curso.upper())
>>> PYTHON

print(curso.lower())
>>> python

print(curso.title())
>>> Python
```

##### Eliminar espa√ßos em branco

```python
curso = " Python "

print(curso.strip())
>>> "Python"

print(curso.lstrip())
>>> "Python "

print(curso.rstrip())
>>> " Python"
```

##### Jun√ß√µes e centraliza√ß√£o

```python
curso = "Python"

print(curso.center(10, "#"))
>>> "##Python##"

print(".".join(curso))
>>> "P.y.t.h.o.n"
```

#### 5.2 Interpola√ß√£o de Vari√°veis

Em Python temos 3 formas de interpolar vari√°veis em strings:
* Usando o sinal %;
* O m√©todo format;
* f strings.

> A primeira forma n√£o √© atualmente recomendada e seu uso em Python 3 √© raro.

##### Format

```python
nome = "Carol"
idade = "28"
profissao = "progamadora"
curso = "python"

print("Ol√°, eu me chamo {}. Tenho {} anos, trabalho como {} e estou aprendendo {}." .format(nome, idade, profissao, curso))

# ou 

print ("Ol√°, eu me chamo {1}. Tenho {0} anos, trabalho como {2} e estou aprendendo {3}." .format(idade, nome, profissao, curso))
```

##### F-String

```python
nome = "Carol"
idade = "28"
profissao = "progamadora"
curso = "python"

print(f"Ol√°, eu me chamo {nome}. Tenho {idade} anos, trabalho como {profissao} e estou aprendendo {curso}.")
>>> "Ol√°, eu me chamo Carol. Tenho 28 anos, trabalho como progamadora e estou aprendendo python."
```

Pode receber argumentos de formata√ß√£o:
* caracteres totais na string;
> OBS: Considera os caracteres da string e acrescenta, em espa√ßos vazios, o que falta para chegar ao n√∫mero informado.
>
>Ex. Se o argumento for 10, e a palavra for "arroz", ser√£o acrescidos 5 espa√ßos em branco antes da palavra.
* digitos ap√≥s a v√≠rgula.

```python
PI = 3.14159

print(f"Pi √© igual a: {PI:.2f}")
>>> "Pi √© igual a: 3.14"

print(f"Pi √© igual a: {PI:10.2f}")
>>> "Pi √© igual a:       3.14"
```

#### 5.3 Fatiamento de Strings

Fatiamento de strings √© uma t√©cnica utilizada para retornar substrings (partes da string original), informando inicio (start), fim (stop) e passo (step).

```python
nome: "Guilherme Arthur de Carvalho"

nome[0]
>>> "G"

nome[:9]
>>> "Guilherme"

nome[10:]
>>> "Arthur de Carvalho"

nome[10:16]
>>> "Arthur"

nome[10:16:2] # a partir do 10, at√© o 16, pulando um caractere.
>>> "Atu"

nome[:]
>>> "Guilherme Arthur de Carvalho"

nome[::-1]
>>> "ohlavraC ed ruhtrA emrehliuG"
```

#### 5.4 String de M√∫ltiplas Linhas

Strings de m√∫ltiplas linhas s√£o definidas informando 3 aspas simples ou duplas durante a atribui√ß√£o. 
* Elas podem ocupar v√°rias linhas do c√≥digo, e todos os espa√ßos em branco s√£o inclu√≠dos na string final. 

```python
nome = "Guilherme"

mensagem = f"""
Ol√°, meu nome √© {nome}.
    Estou aprendendo Python.
"""
print(mensagem)

>>> Ol√°, meu nome √© Guiherme.
     Estou aprendendo Python.
```
---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 6. Listas e Tuplas

#### 6.1 Cria√ß√£o e Acesso aos Dados

**Listas**, em Python, podem armazenar, de maneira sequencial,
qualquer tipo de objeto.

Listas s√£o objetos mut√°veis, portanto podemos alterar seus valores ap√≥s a cria√ß√£o.

> Quase todos os m√©todos aplicados a listas, tamb√©m podem ser utilizados em tuplas.
>
> A principal diferen√ßa entre os dois est√° no fato de que a tupla √© imut√°vel. Assim, os m√©todos que alteram valores na lista n√£o funcionam na tupla. >
>
> Al√©m disso, a forma como os dados s√£o declarados √© diferente.

Podemos criar **listas** utilizando o construtor list, a fun√ß√£o range ou colocando valores separados por v√≠rgula dentro de colchetes:

```python
letras = list("python")

numeros = list(range(10))

frutas = ["laranja", "maca", "uva"]
```

> OBS: Uma lista pode ser declarada sem valores.

**Tuplas** s√£o criadas a patir da classe **tuple**, ou colocando valores separados por v√≠rula de par√™nteses.

```python
frutas = ("laranja", "pera", "uva",)

pais = ("Brasil",)

letras = tuple("python")

numeros = tuple([1, 2, 3, 4])
```

> OBS: √â uma boa pr√°tica colocar uma v√≠rgula ao fim dos elementos declarados, para que o Python n√£o confunda a tupla com preced√™ncia em opera√ß√µes.

A lista √© uma sequ√™ncia, portanto podemos acessar seus dados utilizando √≠ndices 
* Contamos o √≠ndice de determinada sequ√™ncia a partir do zero.

```python
frutas = ["ma√ß√£", "laranja", "uva", "p√™ra"]
frutas[0] 
# ma√ß√£
frutas[2] 
# uva
```

Sequ√™ncias tamb√©m suportam indexa√ß√£o negativa, e a contagem come√ßa em 1:

```python
frutas = ["ma√ß√£", "laranja", "uva", "p√™ra"]
frutas[-4] 
# ma√ß√£
frutas[-2] 
# uva
```

Tupla: ‚úî

##### Listas Aninhadas

Listas podem armazenar todos os tipos de objetos Python,
portanto podemos ter listas que armazenam outras listas.
Com isso, surgem estruturas bidimensionais, que podem ser
acessadas informando os √≠ndices de linha e coluna.

```python
matriz = [
  [1, "a", 2],
  ["b", 3, 4],
  [6, 5, "c"]
]

# Para acessar os itens da matriz

matriz[0] 
# [1, "a", 2]
matriz[0][-1] 
# 2
```

Tupla: ‚úî

##### Fatiamento de Listas

Al√©m de acessar elementos diretamente, podemos extrair um
conjunto de valores de uma sequ√™ncia.

Para isso basta passar o √≠ndice inicial e/ou final para acessar o conjunto.

Podemos, ainda, informar quantas posi√ß√µes o cursor deve "pular" no acesso.

```python
lista = ["p", "y", "t", "h", "o", "n"]

lista[2:] 
# ["t", "h", "o", "n"]
lista[0:3:2] 
# ["p", "t"]
lista[::-1] 
# ["n", "o", "h", "t", "y", "p"]
```

> LEMBRETE: O √∫tlimo valor n√£o √© retornado.

Tupla: ‚úî

##### Iterar Listas

A forma mais comum para percorrer os dados de uma lista √© utilizando o comando **for**.

```python
carros = ["gol", "celta", "palio"]

for carro in carros:
  print(carro)
```

Tupla: ‚úî

##### Fun√ß√£o Enumerate

√Äs vezes √© necess√°rio saber qual o √≠ndice do objeto dentro do la√ßo for Para isso podemos usar a fun√ß√£o enumerate.

```python
carros = ["gol", "celta", "palio"]

for incdice, carro in enumerate(carros):
  print(f"{indice}: {carro}")
```

Tupla: ‚úî

##### Compreens√£o de Listas

A compreens√£o de lista oferece uma sintaxe mais curta
ao criar uma nova lista com base nos valores
de uma lista existente, ou aplicando alguma modifica√ß√£o nos elementos de uma lista existente.

```python
numeros = [1, 30, 21, 2, 9, 65, 34]
pares = []

for numero in numeros:
  if numero % 2 == 0:
    pares.append(numero)

# ou

pares = [numero for numero in numeros if numero % 2 == 0]
```
Tupla: ‚ö† 
> Funciona, mas a classe a receber os elementos (no caso, **pares**) deve ser uma lista, e n√£o uma tupla.

#### 6.2 M√©todos da classe list

##### append()

Tupla: ‚ùå

Adiciona elementos √† lista.

```python
lista = []

lista.append(1)
lista.append("Python")
lista.append([40, 30, 20])

print(lista)
>>> [1, "Python", [40, 30, 20]]
```

##### clear()

Tupla: ‚ùå

Limpa todos os elementos da lista.

```python
lista = [1, Python, [40, 30, 20]]

lista.clear()

print(lista)
>>> 
```

##### copy()

Tupla: ‚ùå

Retorna uma lista diferente com os mesmos elementos da original. Ou seja, cria uma segunda lista com um **id** diferente.

```python
lista = [1, "Python", [40, 30, 20]]

lista.copy()

print(lista)
>>> [1, "Python", [40, 30, 20]]
```

##### count()

Tupla: ‚úî

Conta o n√∫mero de vezes que um elemento aparece na lista.

```python
cores = [" vermelho", " azul", " verde", "azul"]

cores.count(" vermelho") 
# 1
cores.count(" azul") 
# 2
cores.count(" verde") 
# 1
```

##### extend()

Tupla: ‚ùå

Utilizado para juntar duas listas diferentes.

> Inclusive elementos repetidos.

```python
linguagens = [" python", " js", "c"]

print(linguagens) 
>>> ["python", "js", "c"]

linguagens.extend(["java", "csharp"])

print(linguagens) 
>>> ["python", "js", "c", "java", "csharp"]
```

##### index()

Tupla: ‚úî

Retorna o √≠ndice da primeira ocorr√™ncia do objeto.

```python
linguagens = ["python", " js", " c", " java", "csharp"]

linguagens.index("java") 
# 3
linguagens.index("python") 
# 0
```

##### pop()

Tupla: ‚ùå

Retira da lista o √∫ltimo elemento, a menos que o √≠ndice seja passado entre os par√™nteses.

```python
linguagens = ["python", "js", "c", "java", "csharp"]

linguagens.pop() 
# csharp
linguagens.pop() 
# java
linguagens.pop() 
# c
linguagens.pop(0) 
# python

print(linguagens)
>>> "js"
```

##### remove()

Tupla: ‚ùå

```python
linguagens = [" python", " js", " c", " java", "csharp"]

linguagens.remove("c")

print(linguagens) 
>>> ["python", "js", "java", "csharp"]
```

##### reverse()

Tupla: ‚ùå

```python
linguagens = ["python", " js", " c", " java", "csharp"]

linguagens.reverse()

print(linguagens) 
>>> ["csharp", "java", "c", "js", "python"]
```

##### sort()

Tupla: ‚ùå

```python
linguagens = ["python", " js", "c", " java", "csharp"]

linguagens.sort() 
>>> ["c", "csharp", "java", "js", "python"]

linguagens.sort(reverse=True)
>>> ["python", "js", "java", "csharp", "c"]

# Ordena√ß√£o crescente por tamanho das palavras
linguagens.sort(key= lambda x: len(x)) 
>>> ["c", "js", "java", "python", "csharp"]

# Ordena√ß√£o decrescente por tamanho das palavras
linguagens.sort(key= lambda x: len(x), reverse= True ) 
>>> ["python", "csharp", "java", "js", "c"]
```

##### len()

Tupla: ‚úî

Retorna o tamanho da lista.

```python
linguagens = ["python", " js", "c", " java", "csharp"]

len(linguagens) 
# 5
```

##### sorted()

Tupla: ‚úî

```python
linguagens = ["python", "js", " c", " java", "csharp"]

# Ordena√ß√£o crescente por tamanho das palavras
sorted(linguagens, key=
lambda x: len(x)) 
>>> ["c", "js", "java", "python", "csharp"]

# Ordena√ß√£o decrescente por tamanho das palavras
sorted(linguagens, key=
lambda x: len(x), reverse= True) 
>>> ["python", "csharp",
"java", "js", "c"]
```
---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 7. Conjuntos

#### 7.1 Cria√ß√£o e Acesso aos Dados

Um **set** √© uma cole√ß√£o que n√£o possui objetos repetidos.

Usamos sets para representar conjuntos matem√°ticos ou eliminar itens duplicados de um iter√°vel.

```python
set([1 , 2 , 3 , 1 , 3 , 4 ]) 
# {1, 2, 3, 4)

set(" abacaxi") 
# {"b", "a", "c", "x", "i"}

set((" palio", " gol", " celta", " palio")) 
# {"gol", "celta", "palio"}
```

Conjuntos em Python n√£o suportam indexa√ß√£o e nem
fatiamento, caso seja necess√°rio acessar os seus valores, √© preciso converter o conjunto para lista.

```python
numeros = {1, 2, 3, 4}

numeros = list(numeros)

numeros[0]
# 1
```

##### Iterar Conjuntos

A forma mais comum para percorrer os dados de um conjunto √© utilizando o comando for.

```python
carros = {"gol", "celta", "palio"}

for carro in carros:
  print(carro)
```

##### Fun√ß√£o Enumerate

√Äs vezes √© necess√°rio saber qual o √≠ndice do objeto dentro do la√ßo for Para isso podemos usar a fun√ß√£o enumerate.

```python
carros = {"gol", "celta", "palio"}

for indice, carro in enumerate(carros):
  print(f"{indice}: {carro}")
```

#### 7.2 M√©todos da classe set

##### union()

![uni√£o](./image/uniao-conjuntos.png)

```python
conjunto_a = {1 , 2}
conjunto_b = {3 , 4}

conjunto_a.union(conjunto_b) 
# {1, 2, 3, 4}
```

##### intersection()

![intersec√ß√£o](./image/intersecao-conjuntos.png)

```python
conjunto_a = {1 , 2 , 3}
conjunto_b = {2 , 3 , 4}

conjunto_a.intersection(conjunto_b) 
# {2, 3}
```

##### difference()

![diferen√ßa](./image/diferenca-conjuntos.png)

```python
conjunto_a = {1 , 2 , 3}
conjunto_b = {2 , 3 , 4}

conjunto_a.difference(conjunto_b) 
# {1}
conjunto_b.difference(conjunto_a) 
# {4}
```

##### symmetric_difference()

![diferen√ßa sim√©trica](./image/diferenca-simetrica-conjuntos.png)

```python
conjunto_a = {1 , 2 , 3}
conjunto_b = {2 , 3 , 4}

conjunto_a.symmetric_difference(conjunto_b) 
# {1, 4}
```

##### issubset()

Verifica se um conjunto √© subconjunto de outro e retorna valores booleanos.

```python
conjunto_a = {1, 2, 3}
conjunto_b = {4, 1, 2, 5, 6, 3}

conjunto_a.issubset(conjunto_b) 
# True
conjunto_b.issubset(conjunto_a) 
# False
```

##### issuperset()

Verifica se um conjunto cont√©m outro e retorna valores booleanos.

```python
conjunto_a = {1, 2, 3}
conjunto_b = {4, 1, 2, 5, 6, 3}

conjunto_a.issuperset(conjunto_b) 
# False
conjunto_b.issuperset(conjunto_a) 
# True
```

##### isdisjoint()

Verifica se dois conjuntos n√£o tem nenhuma rela√ß√£o e retorna valores booleanos.

```python
conjunto_a = {1, 2, 3, 4, 5}
conjunto_b = {6, 7, 8, 9}
conjunto_c = {1 , 0}

conjunto_a.isdisjoint(conjunto_b) 
# True
conjunto_a.isdisjoint(conjunto_c) 
# False
```

##### add()

```python
sorteio = {1 , 23}

sorteio.add(25) 
# {1, 23, 25}
sorteio.add(42) 
# {1, 23, 25, 42}
sorteio.add(25) 
# {1, 23, 25, 42} 
# Nada acontece porque o n√∫mero 25 j√° estava no conjunto
```

##### clear()

```python
sorteio = {1 , 23}

sorteio.clear()

sorteio 
# {}
```

##### copy()

```python
sorteio = {1 , 23}

sorteio 
# {1, 23}

sorteado = sorteio.copy()
sorteio 
# {1, 23}
sorteado 
# {1, 23}
```

##### discard()

```python
numeros = {1, 2, 3, 1, 2, 4, 5, 5, 6, 7, 8, 9, 0}

numeros 
# {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}

numeros.discard(1)

numeros.discard(45)

numeros 
# {2, 3, 4, 5, 6, 7, 8, 9, 0}
```

##### pop()

```python
numeros = {1, 2, 3, 1, 2, 4, 5, 5, 6, 7, 8, 9, 0}

numeros 
# {0, 1, 2, 3, 4, 5, 6, 7, 8,

numeros.pop() 
# 0
numeros.pop() 
# 1

numeros 
# {2, 3, 4, 5, 6, 7, 8, 9}
```

##### rmemove()

```python
numeros = {1 , 2 , 3 , 1 , 2 , 4 , 5 , 5 , 6 , 7 , 8 , 9 , 0}

numeros 
# {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

numeros.remove(0) 
# 0

numeros 
# {1, 2, 3, 4, 5, 6, 7, 8, 9}
```

> A diferen√ßa entre discard() e remove() √© que o primeiro n√£o retorna erro se for pedido para que seja descartado um n√∫mero que n√£o est√° no conjunto.

##### len()

```python
numeros = {1, 2, 3, 1, 2, 4, 5, 5, 6, 7, 8, 9, 0}

len(numeros) 
# 10
```

##### in()

```python
numeros = {1, 2, 3, 1, 2, 4, 5, 5, 6, 7, 8, 9, 0}

1 in numeros 
# True

10 in numeros 
# False
```

---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 8. Dicion√°rios

#### 8.1 Cria√ß√£o de Dicion√°rios e Acesso aos Dados

Um **dicion√°rio** √© um conjunto **n√£o ordenado** de pares chave-valor, onde as chaves s√£o √∫nicas em uma dada inst√¢ncia do dicion√°rio.

Dicion√°rios s√£o delimitados por chaves e cont√©m uma lista de pares chave-valor separada por v√≠rgulas.

```python
pessoa = {"nome": "Guilherme", "idade": 28}

pessoa = dict(nome = "Guilherme", idade = 28)

pessoa["telefone"] = "3333-1234"
# {"nome": "Guilherme", "idade": 28, "telefone": "3333-1234"}
```

Os dados s√£o acessados e modificados atrav√©s da chave.

```python
dados = {"nome": "Guilherme", "idade": 28 , "telefone": "3333-1234"}

dados["nome"] 
# "Guilherme"
dados["idade"] 
# 28
dados["telefone"] 
# "3333-1234"

# Para sobrescrever os valores do dicion√°rio

dados["nome"] = "Maria"
dados["idade"] = 18
dados["telefone"] = "9988-1781"

print(dados) 
>>> {"nome": "Maria", "idade": 18, "telefone": "9988-1781"}
```

##### Dicion√°rios Aninhados

**Dicion√°rios** podem armazenar qualquer tipo de objeto Python como valor, desde que a chave para esse valor seja um objeto imut√°vel como (strings e n√∫meros).

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme", " telefone": "3333-2221"},
  "giovanna@gmail.com": {"nome": "Giovanna", "telefone": "3443-2121"},
  "chappie@gmail.com": {"nome": "Chappie", "telefone": "3344-9871"},
  "melaine@gmail.com": {"nome": "Melaine", "telefone": "3333-7766"},
}

print(contatos["giovanna@gmail.com"]["telefone"])
>>> "3443-2121"
```

> OBS: Para acessar um dicion√°rio dentro de outro dicion√°rio, n√£o importa quantos n√≠veis abaixo do primeiro, √© s√≥ acrescentar a chave desejada entre colchetes.
>
> Ex. print(contatos["guilherme@gmail.com"]["nome_completo"]["sobrenome"])

##### Iterar Dicion√°rios

A forma mais comum para percorrer os dados de um dicion√°rio √© utilizando o comando **for**.

```python
for chave in contatos:
  print(chave, contatos[chave])

# ou, de forma melhor:

for chave, valor in contatos.items():
  print(chave, valor)

>>> guilherme@gmail.com {'nome': 'Guilherme', 'telefone': '3333-2221'}
>>> giovanna@gmail.com {'nome': 'Giovanna', 'telefone': '3443-2121'}
>>> chappie@gmail.com {'nome': 'Chappie', 'telefone': '3344-9871'}
>>> melaine@gmail.com {'nome': 'Melaine', 'telefone': '3333-7766'}
```

#### 8.2 M√©todos da classe dict

##### clear()

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme", "telefone": "3333-2221"},
  "giovanna@gmail.com": {"nome": "Giovanna", "telefone": "3443-2121"},
  "chappie@gmail.com": {"nome": "Chappie", "telefone": "3344-9871"},
  "melaine@gmail.com": {"nome": "Melaine", " telefone": "3333-7766"},
}

contatos.clear()

print(contatos) 
>>> {}
```

##### copy()

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme", "telefone": "3333-2221"},
}

copia = contatos.copy()

copia["guilherme@gmail.com"] = {"nome": "Gui"}

print(contatos["guilherme@gmail.com"]) 
# {"nome": "Guilherme", "telefone": "3333-2221"}

print(copia["guilherme@gmail.com"]) 
# {"nome": "Gui"}
```

##### fromkeys()

Cria chaves com ou sem valores vincuados. Em um dicion√°rio existente ou n√£o.

```python
nome-do-dicionario.fromkeys(["nome", "telefone"]) 
# {"nome": None, "telefone": None}

dict.fromkeys(["nome", "telefone"], "vazio") 
# {"nome": "vazio", "telefone": "vazio"
```

##### get()

O m√©todo get() tamb√©m retorna valores, e √© mais comumente utilizado quando n√£o se sabe se uma chave existe dentro de um dicion√°rio.

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme", "telefone": "3333-2221"}
}

contatos["chave"] 
# KeyError

contatos.get("chave") 
# None
# Retorno padr√£o.

contatos.get("chave", {}) 
# {}
# O segundo argumento define o retorno padr√£o caso uma chave n√£o exista.

contatos.get("guilherme@gmail.com", {}) 
# {"guilherme@gmail.com": {"nome": "Guilherme", "telefone": "3333-2221"}
```

##### items()

Retorna uma lista de tupas, contendo os itens do dicion√°rio.

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme","telefone": "3333-2221"}
}

contatos.items() 
# dict_items([('guilherme@gmail.com', {'nome': 'Guilherme', 'telefone': '3333-2221'})])
```

##### keys()

Retorna as chaves do dicion√°rio.

```python
contatos = {
"guilherme@gmail.com": {"nome": "Guilherme"," telefone": "3333-2221"}
}

contatos.keys() 
# dict_keys(['guilherme@gmail.com'])
```

##### pop()

Remove a chave de um dicion√°rio.

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme","telefone": "3333-2221"}
}

contatos.pop("guilherme@gmail.com") 
# {'nome': 'Guilherme','telefone': '3333-2221'}

contatos.pop("guilherme@gmail.com", {}) 
# {}
```

##### popitem()

Remove os valores de uma chave.

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme","telefone": "3333-2221"}
}

contatos.popitem() 
# ('guilherme@gmail.com', {'nome': 'Guilherme', 'telefone':'3333-2221'})

contatos.popitem() 
# KeyError
```

##### detdefault()

Se a chave n√£o existir no dicion√°rio, ela √© adicionada com o valor declarado. 

Se a chave exisir no dicion√°rio, nada acontece (o valor n√£o √© atualizado).

```python
contato = {'nome': 'Guilherme', 'telefone': '3333-2221'}

contato.setdefault("nome", "Giovanna") 
# Guilherme

contato 
# {'nome': 'Guilherme', 'telefone': '3333-2221'}

contato.setdefault("idade", 28) 
# 28

contato 
# {'nome': 'Guilherme', 'telefone': '3333-2221', 'idade': 28}
```

##### update()

Se a chave n√£o existir no dicion√°rio, ela √© adicionada com o valor declarado. 

Se a chave exisir no dicion√°rio, o valor √© atualizado.

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme","telefone": "3333-2221"}
}

contatos.update({"guilherme@gmail.com": {"nome": "Gui"}})

contatos 
# {'guilherme@gmail.com': {'nome': 'Gui}

contatos.update({"giovanna@gmail.com": {"nome": "Giovanna", "telefone": "3322-8181"}})

contatos 
# {'guilherme@gmail.com': {'nome': 'Gui'}, 'giovanna@gmail.com': {'nome': 'Giovanna', 'telefone': '3322 8181'}}
```

##### values()

Retorna os valores do dicion√°rio.

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme", "telefone": "3333-2221"},
  "giovanna@gmail.com": {"nome": "Giovanna", "telefone": "3443-2121"},
  "chappie@gmail.com": {"nome": "Chappie", "telefone": "3344-9871"},
  "melaine@gmail.com": {"nome": "Melaine", "telefone": "3333-7766"},
}

contatos.values() 
# dict_values([{'nome': 'Guilherme', 'telefone': '3333-2221'}, {'nome': 'Giovanna', 'telefone': '3443-2121'}, {'nome': 'Chappie','telefone': '3344 9871'}, {'nome': 'Melaine', 'telefone': '3333 7766'}])
```

##### in()

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme", "telefone": "3333-2221"},
  "giovanna@gmail.com": {"nome": "Giovanna", "telefone": "3443-2121"},
  "chappie@gmail.com": {"nome": "Chappie", "telefone": "3344-9871"},
  "melaine@gmail.com": {"nome": "Melaine", "telefone": "3333-7766"},
}

"guilherme@gmail.com" in contatos 
# True

"megui@gmail.com" in contatos 
# False

"idade" in contatos ["guilherme@gmail.com"] 
# False

"telefone" in contatos ["giovanna@gmail. com"] 
# True
```

##### del()

```python
contatos = {
  "guilherme@gmail.com": {"nome": "Guilherme", "telefone": "3333-2221"},
  "giovanna@gmail.com": {"nome": "Giovanna", "telefone": "3443-2121"},
  "chappie@gmail.com": {"nome": "Chappie", "telefone": "3344-9871"},
  "melaine@gmail.com": {"nome": "Melaine", "telefone": "3333-7766"},
}

del contatos["guilherme@gmail.com"]["telefone"]
del contatos["chappie@gmail.com"]

contatos
# {'guilherme@gmail.com': {'nome': 'Guilherme'}, 'giovanna@gmail.com': {'nome': 'Giovanna', 'telefone': '3443 2121'}, 'melaine@gmail.com': {'nome':'Melaine', 'telefone': '3333 7766'}}
```
---
Feito por cla-isse üíú

## ![PYTHON](https://img.shields.io/badge/Python-000?style=for-the-badge&logo=python)

### 9. Fun√ß√µes

Fun√ß√£o √© um bloco de c√≥digo identificado por um nome e pode
receber uma lista de par√¢metros. Esses par√¢metros podem ou
n√£o ter valores padr√µes.

Usar fun√ß√µes torna o c√≥digo mais
leg√≠vel e possibilita o reaproveitamento de c√≥digo.

Programar baseado em fun√ß√µes, √© o mesmo que dizer que estamos
programando de maneira estruturada.

```python
def exibir_mensagem():
  print("Ol√° Mundo!")

exibir_mensagem()
>>> Ol√° Mundo!
```

##### Argumentos Nomeados

Fun√ß√µes podem ser chamadas usando argumentos
nomeados da forma chave=valor.

```python
def salvar_carro(marca, modelo, ano, placa):
  # salva carro no banco de dados
  print(f"Carro inserido com sucesso! {marca}/{modelo}/{ano}/{placa}")

salvar_carro("Fiat", "Palio", 1999, "ABC-1234")

# ou

salvar_carro(marca="Fiat", modelo="Palio", ano=1999, placa="ABC-1234")

# ou

salvar_carro(**{"marca": "Fiat", "modelo":"Palio", "ano": 1999, "placa":"ABC-1234"})

# Carro inserido com sucesso! Fiat/Palio/1999/ABC-1234
```

##### Return()

Para retornar um valor, utilizamos a palavra reservada **return**. Toda fun√ß√£o Python retorna *None* por padr√£o. 
Diferente de outras linguagens de programa√ß√£o, em Python uma fun√ß√£o pode retornar mais de um valor.

```python
def retorna_antecessor_sucessor(numero):
  antecessor = numero - 1
  sucessor = numero + 1
  
  return antecessor, sucessor

print(retorna_antecessor_sucessor(10))
>>> 9, 11
```

##### Args e Kwargs

Podemos combinar par√¢metros obrigat√≥rios com args e
kwargs Quando esses s√£o definidos (*args e **kwargs), o
m√©todo recebe os valores como tupla e dicion√°rio
respectivamente.

```python
def exibir_poema(data_extenso, *args, **kwargs):
  texto = "\n".join(args)
  meta_dados = "\n".join([f"{chave.title()}:{valor}" for chave, valor in kwargs.items()])
  mensagem = f"{data_extenso}\n\n{texto}\n\n{meta_dados}"
  print(mensagem)

exibir_poema("Zen of Python", "Beautiful is better than ugly.", autor="Tim Peters", ano=1999)
```

##### Par√¢metros Especiais

Por padr√£o, argumentos podem ser passados para uma fun√ß√£o
Python tanto por posi√ß√£o quanto explicitamente pelo nome.

Para uma melhor legibilidade e desempenho, faz sentido restringir a maneira pela qual argumentos possam ser passados, assim um desenvolvedor precisa apenas olhar para a defini√ß√£o da fun√ß√£o para determinar se os itens s√£o passados por posi√ß√£o, por posi√ß√£o e nome, ou apenas nome.

![Par√¢metros Especiais](./image/parametros-especiais.png)

###### Positional Only

```python
def criar_carro (modelo, ano, placa, /, marca, motor, combustivel):
  print(modelo, ano, placa, marca, motor, combustivel)

criar_carro("Palio", 1999, "ABC-1234", marca="Fiat", motor="1.0",combustivel="Gasolina") 
# v√°lido

criar_carro(modelo="Palio", ano=1999, placa="ABC-1234", marca="Fiat",motor=" 1.0", combustivel="Gasolina") 
# inv√°lido
```

###### Keyword Only

```python
def criar_carro (*, modelo, ano, placa, marca, motor, combustivel):
  print(modelo, ano, placa, marca, motor, combustivel)

criar_carro(modelo="Palio", ano =1999, placa="ABC-1234", marca="Fiat",
motor="1.0", combustivel="Gasolina") 
# v√°lido

criar_carro("Palio", 1999, "ABC-1234", marca="Fiat", motor="1.0",
combustivel="Gasolina") 
# inv√°lido
```

###### Keyword and Positional Only

```python
def criar_carro (modelo, ano, placa, /, *, marca, motor, combustivel):
  print(modelo, ano, placa, marca, motor, combustivel)

criar_carro("Palio", 1999, "ABC 1234", marca="Fiat", motor="1.0", combustivel="Gasolina") 
# v√°lido

criar_carro(modelo="Palio", ano=1999, placa="ABC-1234", marca="Fiat", motor="1.0", combustivel="Gasolina")
# inv√°lido
```

###### Objetos de Primeira Classe

Em Python tudo √© objeto, dessa forma fun√ß√µes tamb√©m s√£o
objetos. Isso as torna objetos de primeira classe.

Isso significa que √© pos√≠vel:
* Atribuir fun√ß√µes a vari√°veis;
* Pass√°-las como par√¢metro para outras fun√ß√µes;
* Us√°-las como valores em estruturas de dados (tuplas, dicion√°rios, etc);
* Us√°-las como valor de retorno para uma fun√ß√£o (closures).

```python
def somar (a, b):
  return a + b

def exibir_resultado (a, b, funcao):
  resultado = funcao(a, b)
  print(f"O resultado da opera√ß√£o {a} + {b} = {resultado}")

exibir_resultado(10, 10, somar) 
# O resultado da opera√ß√£o 10 + 10 = 20
```

###### Escopo Local e Global

Python trabalha com escopo local e global.

Dentro do bloco da fun√ß√£o, o **escopo √© local**, portanto altera√ß√µes ali feitas em objetos imut√°veis ser√£o perdidas quando o m√©todo terminar de ser executado.

Para usar objetos globais, utilizamos a palavra chave **global**, que informa ao interpretador que a vari√°vel que est√° sendo manipulada no escopo local √© global.
> Essa N√ÉO √© uma boa pr√°tica e deve ser evitada

```python
salario = 2000

def salario_bonus(bonus):
  global salario
  salario += bonus
  return salario

salario_bonus(500)
>>> 2500
```
---
Feito por cla-isse üíú
